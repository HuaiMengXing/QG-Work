#### 大组作业02：范式链队列

****

**目录**



[TOC]

****

#### 题目&要求

+ **必做**：实现链式存储的泛型队列、周记一篇

  ​           例如Java的Queue< E >使用者能够选择不同的存储方式。即使存储方式、以及内部方式

  ​           不同，外部接口一定要相同。（提示：巧用void*(无类型指针)）

+ **要求**：按照项目工程结构开发，要有良好的交互设计、用户输入处理、规范的代码风格。

  ​            周记要使用Markdown语法，按照规定格式书写

****

#### 使用说明&存在问题

**主功能界面**

+ 链式存储的泛型队列

**使用说明**

+ 进入界面会有简单的提示，按提示输入即可。
+ 在选择处有报错功能，但是输入值没有。

**存在问题**

+ 在入队列功能中，选择值的时候，要求选择什么输入什么。
+ - 不能在int型中输入double型。
  - 不能在int、double型中输入string型。
  - 以上话，都会存在问题，可能**程序崩溃！！！**
+ 因为可以存储不同类型的数据，所以我不对输入值做处理。

****

#### 整体设计思路分析

+ 永远是那句话，首先是定义好链队列的结果，做好框架。
+ - 利用class封装，做好接口，调用。
  - 一个个函数接口检测，检查，运行找错，修改。
  - 最后完成所有函数，进行优化，检测问题。
  - 没问题则返回检查，在需要的地方加上注释。
  - 以上是基本的。
+ 链队列与链栈不是差太多，所以要求基本一样。
+ 对于泛型呢，利用void*指针的性质，实现不同的数据类型的输入。有点类似模板

**各功能模块设计**

+ **1、创建队列**
+ - 创建头尾指针和一个带头的队列。
+ **2、销毁队列，清空队列**
+ - 清空队列则是逐步释放各个结点内存，留下指向队列的front和rear指针，并且rear指回front
  - 更新长度，同时队列不存在或者为空，清空失败。
  - 销毁队列则是连指向链队列的Q指针也释放掉。
  - 同时队列不存在时，销毁失败。
+ **3、检查队列是否为空**
+ - 分三种情况：
  - - 队列不存在!或者已经销毁。
    - 队列已经创建,但队列为空。
    - 队列已经创建,队列不为空。
+ **4、查看返回队头元素**
+ - 将front指向的数据拿到手，然后调用打印函数打印，同时返回这个数据
+ **5、确定返回队列长度**
+ - 利用结构体里面定义的长度，返回。
+ **6、打印**
+ - 调用这个函数需要传入两个数据
  - - 1、是这个结点的数据
    - 2、是这个结点数据的字节大小，用来判断，怎样打印这个数据
+ **7、入队操作（赋值）**
+ - 主要的是调用赋值函数来实现，赋值成功后，
  - 新结点赋给原队列结点后面，把当前结点设置为队尾结点，长度++。
+ 赋值函数
+ - 调用这个函数需要传入两个数据
  - 1、是这个结点的数据（引用的方式）
  - - 开辟空间，通过用户选择来赋什么样的值，定义void*是什么类型。
  - 2、是这个结点数据的字节大小，用来判断，怎样打印这个数据
  - - 选择完成后，将这个类型的字节赋值给size。
+ **8、出队操作**
+ front指针后移，然后释放前面那一个结点，如果队头就是队尾的情况，尾指针指回头指针。

+ **9、遍历**
+ 调用打印函数遍历。

****

#### 代码实现&测试结果

+ **1、创建队列**

~~~c++
Node* p = new Node;
	(*Q) = new LQueue;
	(*Q)->front = p;
	(*Q)->rear = p;
	(*Q)->length = 0;

测试：创建成功！
~~~

+ **2、销毁队列，清空队**

~~~c++
    Node* p, * q = NULL;
	for (p = (*Q)->front->next; p; p = q)
	{
		q = p->next;
		delete p;
	}
	delete (*Q)->front;//头结点也放了《-----这些是销毁队列时需要的代码
	delete *Q;//这个指向头结点的也放了《-----这些是销毁队列时需要的代码
	*Q = NULL;

测试：销毁成功！
    
测试：清空成功！
~~~

+ **3、检查队列是否为空**

~~~c++
	if (Q == NULL)//已经销毁
	{
		return -1;
	}
	else if (Q->front == Q->rear)//为空
	{
		return 0;
	}
	return 1;//不为空
~~~

+ **4、查看返回队头元素**

~~~c++
std::cout << "\t队头元素为：";
	LPrint(Q->front->next->data, Q->front->next->size);//打印
~~~

+ **5、返回队列长度**
+ **6、打印**

~~~c++
void LPrint(void* q,int size)//对void*的要作业处理，才能找到值
{
	if (size == sizeof(int))
	{
		std::cout << *(int*)q << " - ";
	}
	else if(size == sizeof(double))
	{
		std::cout << *(double*)q << " - ";
	}
	else if (size == sizeof(std::string))
	{
		std::cout << *(std::string*)q << " - ";
	}
}
~~~

+ **7、入队操作（赋值）**

~~~c++
    Node* p = new Node;
	if (p == NULL)
	{
		return FALSE;
	}

	//赋值
	p->data = TypeSelect(p->data,p->size);
	p->next = NULL;
	(*Q)->rear->next = p;//新结点赋给原队列结点后面
	(*Q)->rear = p;//把当前结点设置为队尾结点
	(*Q)->length++;//长度++
~~~

+ 赋值函数

~~~c++
int* Data1 = new int;//开辟空间，否则出去就没有了
	double* Data2 = new double;
	std::string* Data3 = new std::string;
	std::string Data_3;//用来中转的

       if (select == "1")
		{
			std::cin >> *Data1;
			data = Data1;
			size = sizeof(int);//赋值字节大小，用来索引
			break;
		}
		else if (select == "2")
		{
			std::cin >> *Data2;
			data = Data2;
			size = sizeof(double);//赋值字节大小，用来索引
			break;
		}
		else if (select == "3")
		{
			std::cin >> Data_3;
			*Data3 = Data_3;//不能直接赋值，那么中转一下
			data = Data3;
			size = sizeof(std::string);//赋值字节大小，用来索引
			break;
		}
~~~

测试：

~~~c++
 请输入您的选择：2
        * ***************赋值类型选择******************* *
        *  1、int        * 2、double      * 3、string    *
        * ********************************************** *
        请选择您的值的类型：3
        请输入您的值：QG
        入队成功!
~~~

+ **8、出队操作**

~~~c++
Node* p = new Node;
	p = (*Q)->front->next;//保留值释放
	(*Q)->front->next = p->next;//后移

	if ((*Q)->rear == p)//队头就是队尾的情况，尾指针指回头指针
		(*Q)->rear = (*Q)->front;

	delete p;//释放
	(*Q)->length--;//长度--

测试：数据出队成功
~~~

+ **9、遍历**

~~~c++
for (p = Q->front->next; p != NULL; p = p->next)//遍历
	{
		LPrint(p->data, p->size);
	}
~~~

~~~c++
测试：
    请输入您的选择：6
        QG - 2022 - 创辉煌 - NULL
~~~



****

#### 思考&小结（两个是一样的*_~）

+ 对于这次作业来说呢，可能对我吧，有一定的难度。因为这次我并不能像上一周那样按时完成任务，怎么来说呢，可能我的知识点真的的有点差吧，速度不够快。但是说实话，我为了这次作业能顺利完成，两天基本在宿舍没有动过了。害、思考一下呢，对于c语言不够熟练，有些时候的错误很简单，但是就是好久才能发现。其次呢，数据结构可能掌握的不是很好，对计算器代码输写的时候，思路不是很清晰，导致基本的框架要搭建很长时间。然后对计算器的运行也经过多次检测，现在应该不会出现代码崩溃或者计算不正确的问题了。而对于链队列呢，主要的是一、对c++的模板不够熟练，刚刚开始想用模板的，可惜出现了许多问题，虽然后面可以实现了，但是觉得不够好。然后去学习void*，可能是由于时间问题，导致可能有点操之过急，不是很好的掌握void *的用法，从而出现了许多代码错误，而自己只能不知所措，浪费了许多时间，这也是不能按时完成任务的问题之一。总的来说，这次任务发现自己有许多问题存在，或许这也是我的收获之一吧。
+ 存在问题是存在，但是呢也不能总是说不好的一方面嘛。这次来说呢，收获是很大的，首先对栈和队列有了一个完全的了解，对链表呢也越来越熟练了。其次呢是计算器代码，对四则运算有了新的认识，从数据结构书上写的，到自己去上网找答案，现在学会了用双栈去实现四则运算，同时对代码逻辑有很大的帮助。对于范式链队列呢，之前都不知道一个链表中可以实现不同的数据类型，以前只是想过一下，现在有了让我实战的机会，怎么可能去放弃呢，虽然说有模板可以简单点，但是不够好（或许是我的模板写的差），去学习void *的用法，过程可能非常艰难，因为网上的知识点好像不是很好（可能我太笨了）。我这次能写出来呢，是结合了网上的说法，然后自己在vs中运行来检测，去分析，最后用到任务上了，当然花费的许多许多时间，不过我也实现的一个链表中存放不同数据类型的代码。所有来说嘛，过程是真的很艰难，但是结果的收获不也是很好吗。这一切都是值得的。
+ 下周计划吗？在我看来，计划可能永远赶不上变化，不过计划还是要有的，我上一周呢已经把图形渲染的初始化学到一半了，这一周应该完成对初始化的学习，然后继续去深入。而对于c++来说，还是要学习的，因为我发现我有时候是真的有点力不从心，所有呢把c++的学习也提上日程来才行。当然身体是革命的本钱，我也要去运动运动了。计划可能是这些吧，因为我计划可能不会想太多，我只是知道我该走的方向，然后去风雨兼程。我的总结就这么多了。
+ 当然还有一点，我很抱歉我不能按时完成任务||。

