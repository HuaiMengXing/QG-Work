#### 大组作业02：计算器&栈

****

**目录**



[TOC]

****

#### 题目&要求

+ **必做**：实现链栈、 实现四则运算表达式（考虑带括号的优先级）求值的计算器

+ **要求**：按照项目工程结构开发，要有良好的交互设计、用户输入处理、规范的代码风格。

  ​           周记要使用Markdown语法，按照规定格式书写。

****

#### 使用说明&存在问题

**主界面功能**

+ - 计算器功能
  - 链栈功能
+ **一、** **计算器功能**
+ - 进入界面会有简单的提示，按提示输入即可。
  - 有报错功能，我暂时没有找到能崩溃的情况，因为检测了许多次，考虑过各种情况。
  - 师兄要是找到，请一定告诉我~_*!
  - 支持小数点，支持超大数据等等输入。
  - - **存在问题**（因为花费时间巨多，问题不多）
    - 界面提示那个不能 ‘-’ 号开头，其他应该没有情况了
    - 代码可能存在复杂性
    - 时间花费多，代码熟练度差
+ **二、 链栈功能**
+ - 界面选择和输入值都有防止输入错误，从而崩溃的处理。
  - 使用时都会有简单的提示，按提示输入即可。
  - 实现所有基本功能。
  - - **存在问题**
    - 代码许多地方没有重复利用，可能有些雍肿。
    - 代码像c，也没用的到模板，c++模板不熟练，用不了。
    - 和计算器没有联系，这可能是最大的问题了，我觉得。

****

#### 整体设计思路分析

+ 首先是定义好链栈的结构，做好框架。
+ - 利用class封装，做好接口，调用。
  - 一个个函数接口检测，检查，运行找错，修改。
  - 最后完成所有函数，进行优化，检测问题。
  - 没问题则返回检查，在需要的地方加上注释。
+ 计算器的首先是在图纸上模拟双栈计算情况
+ - 第一步完成基本栈功能的定义
  - 对计算情况进行考虑，由简单的算式到复杂，慢慢完善代码。
  - 完成基本运算后，开始考虑各种情况问题，再次完善代码。
  - 对可能输入错误的情况进行处理，加强代码的稳定性。
  - 其中这些步骤都离不开无数次测试......。（因为代码能力差吧，多多少少都有点问题）

**各功能模块设计**

**一、链栈功能**

+ **1、初始化栈**
+ - 创建指向栈的top指针，初始化长度。

+ **2、判断栈是否为空或者没有栈**
+ - 分三种情况：
  - - 栈不存在!或者已经销毁。
    - 栈已经创建,但栈为空。
    - 栈已经创建,栈不为空。
+ **3、得到栈顶元素**
+ - 简单的拿top的数据输出，返回。
+ **4、清空栈、销毁栈**
+ - 清空栈则是逐步释放各个结点内存，留下指向栈的top指针。
  - 更新长度，同时栈不存在或者为空，清空失败。
  - 销毁栈则是连指向栈top指针也释放掉。
  - 同时栈不存在时，销毁失败。
+ **5、检测栈长度**
+ 直接返回结构里面的长度，每次入出栈都相应加加减减。
+ **6、入栈、出栈**
+ - 栈不存在时，入出栈都不可以使用，栈为空时，出栈也不可以使用。
  - 入栈则是将当前栈顶结点后继新结点，栈顶指针移位，长度++。
  - 出栈则是将栈顶结点弹出，释放，顶指针后移。
+ **7、栈的遍历**
+ 不动栈顶指向，用里面的链表指针往栈底遍历

**二、计算器功能**

+ **1、栈的基本功能（分为整形栈、字符栈）**
+ - 空判断
  - 入出栈
  - 取栈顶元素
  - 清空栈（防止数据还留栈中，影响后面输入情况）
+ **2、预先处理**
+ - 这个功能是防止乱输入，不是符号或者数字的都输入不进去，后面必须有等号！
+ **3、符号优先级判断**
+ - 这里是判断符号的优先级，让双栈内的数据是否计算。
+ **4、计算&压入**
+ - 错误处理，运算符可以跳过预先处理进来，但是可能运算符都乱放位置。
  - 在整形栈中弹出两个数据，然后弹出字符栈中的运算符，进行相应的计算。
+ **5、压人，计算，弹出流程**
+ - 这里则是整个流程所在了
  - 1、首先用map<char,float>处理用字符输入进来的数字。（输入string字符串进去）
  - 2、数字处理
  - - 处理（-3）情况，因为（）里面一般是要运算的，这种情况就出问题了。
    - 处理小数点，方法是比如这输入 2.33字符  ，2压入了整形栈中 ，遍历到 . 则将后面的数字取出，
    - 并且作为小数，再将整形栈中刚刚压入那个弹出，两个结合再压入整形栈中。
    - 普通的字符数字处理，有多少位连在一起，就一起当一个整体压进去
  - 3、字符处理
  - - 字符栈为空时直接压入。
    - 发现（），则处理（）里面情况。
    - 直到发现 = ，就全部弹出计算。

****

#### 代码实现&测试结果

**一、链栈功能代码实现**

+ **1、初始化栈**

~~~c++
    (*s) = new LinkStack;
	(*s)->top = NULL;
	(*s)->count = 0;

测试：创建成功！
~~~

+ **2、判断栈是否为空或者没有栈**

~~~c++
   if (s == NULL)//不存在栈
	{
		return INEXISTENCE;
	}
	else if (s->count == 0)//栈存在，但是为空
	{
		return ERROR;
	}
	//存在栈且不为空
	return SUCCESS;    
~~~

测试：

~~~c++
    请输入你的选择：6
        栈不存在!或者已经销毁！
    
    请输入你的选择：6
        栈已经创建,但栈为空！
    
     请输入你的选择：6
        栈已经创建,栈不为空！
~~~

+ **3、得到栈顶元素**

~~~c++
std::cout << "\t栈顶元素为：" << S->top->data << std::endl;
	return S->top->data;
~~~

测试：

~~~c++
请输入你的选择：4
        栈顶元素为：1
~~~

+ **4、清空栈，销毁栈**

~~~c++

	LinkStackPtr temp;
	while ((*S)->top != NULL)
	{
		temp = (*S)->top;//保留下来释放
		(*S)->top = (*S)->top->next;//后移
		delete temp;//释放
	}
	(*S)->count = 0;//更新长度

    LinkStackPtr temp;
	while ((*S)->top != NULL)
	{
		temp = (*S)->top;//保留下来释放
		(*S)->top = (*S)->top->next;//后移
		delete temp;//释放
	}
	delete *S;//创建栈的也释放
	(*S) = NULL;
~~~

+ **5、检测长度**
+ **6、入栈**

~~~c++
        LinkStackPtr s = new (StackNode);
		//赋值
		std::string data;
		std::cout << "\t请输入您想进栈的值(字符当0处理)：";
		std::cin >> data;
		s->data = atoi(data.c_str());
		//入栈
		s->next = (*S)->top;//将当前栈顶元素后继新结点
		(*S)->top = s;//栈顶指针移位
		(*S)->count++;//长度++

测试：入栈成功！
~~~

+ **7、出栈**

~~~c++
    LinkStackPtr p = (*S)->top;
	(*S)->top = (*S)->top->next;//栈顶后移
	delete p;
	(*S)->count--;

测试：弹出成功！
~~~

+ **8、栈的遍历**

~~~c++
LinkStackPtr temp = S->top;//不动栈顶指向，用里面的链表

	std::cout << "\t";//界面美观
	while (temp != NULL)
	{
		std::cout << temp->data << "-";
		temp = temp->next;
	}
	std::cout << "栈底" << std::endl;
~~~

测试：

~~~c++
请输入你的选择：7
        34-231-23-12-1-栈底
~~~



**二、计算器功能代码实现**

+ **1、栈基本功能**

+ **2、预先处理**

~~~c++
for (i = 0; i < len; i++)
	{
		if (str[i]<'0' || str[i]>'9')
		{
			if (str[i] != '+' && str[i] != '-' && str[i] != '*' && str[i] != '/' && str[i] != '(' && str[i] != ')' && str[i] != '.'&& str[i]!='=')
			{
				return "#";
			}
		}
	}
	if (str[i-1]!='=')//问题在于不输入=，这些代码虽然不崩溃，但是出来的值就不正确了
	{
		return "#";
	}

测试：输入错误，请重新输入！
~~~

+ **3、符号优先级判断**

~~~c++
int pri = 0;
	if (ch == '=')
	{
		pri = 0;
	}
	if (ch == '(' || ch == ')')
	{
		pri = 1;
	}
	if (ch == '+' || ch == '-')
	{
		pri = 2;
	}
	if (ch == '*' || ch == '/')
	{
		pri = 3;
	}
	return pri;
~~~

+ **4、计算&压入**

~~~c++
if(Char.get_head() == '+')
		Num.push(num2 + num1);//将两个数据和再压入栈中
	if(Char.get_head() == '-')
		Num.push(num2 - num1);//将两个数据差再压入栈中
	if(Char.get_head() == '*')
		Num.push(num2 * num1);//将两个数据*再压入栈中
	if(Char.get_head() == '/')
		Num.push(num2 / num1);//将两个数据/再压入栈中

	Char.pop();//弹出符号
~~~

+ **5、压人，计算，弹出流程**

~~~c++
//map方法，字符对应着可以找到相应的整形
for (ch = '0', l = 0; ch <= '9'; ch++, l++) 
		mp[ch] = l;

//处理（-3）情况
     if (str[i] == '(' && str[i + 1] == '-' && str[i + 3] == ')')
		{
			i = i+2;
			num = 0;
			for (; str[i] >= '0' && str[i] <= '9'; i++)//可能存在几个整形是在一起的
			{
				num = num * 10 + mp[str[i]];
			}
			i++;//（-3）这些全部都要变成 -3 压入，所有（-3）都没有了，i++
			Num.push(-num);
		}

//处理小数点情况
     if (str[i] == '.')
		{
			i = i + 1;
			float num1 = 0;
			float den = 1;
			for (; str[i] >= '0' && str[i] <= '9'; i++)//可能存在几个整形是在一起的
			{
				den *= 10;
				num1 = num1 * 10 + mp[str[i]];
			}
			float num2 = Num.pop();//比如这样 2.33   num2=2  num1=33  den=100
			Num.push(num2 + num1/den);
		}

//整形入口
     if (str[i] >= '0' && str[i] <= '9')
		{
			num = 0;
			for (; str[i] >= '0' && str[i] <= '9'; i++)//可能存在几个整形是在一起的
			{
				num = num * 10 + mp[str[i]];
			}
			Num.push(num);//入栈
			i--;//因为又要回到for中++
        }

//运算符入口
           if (Char.empty()) //字符栈为空时直接push ，不用判断优先级
			{
				Char.push(str[i]);
			}
			else if (priority(str[i]) > priority(Char.get_head()) || str[i] == '(' ||                          str[i] == ')')//待入栈运算符优先级高或是'('和')'push 
			{
				Char.push(str[i]);
				if (str[i] == ')')        //为')'时先弹出')' ，找‘（’
				{
					Char.pop();
					if (Char.get_head() != '(') //op.top不为'('时计算括号中运算符 
					{
						if (!count())
						{
							//能进来，说明输入有错误，清空一下栈，防止下次输入出问题
							Num.clear();
							Char.clear();
							return 0;
						}
					}
					Char.pop(); //pop掉'('
				}
			}
			else //待入栈运算符str[i]优先级低于字符栈顶字符时，先对栈顶运算符进行计算
			{
				if (!count())
				{
					//能进来，说明输入有错误，清空一下栈，防止下次输入出问题
					Num.clear();
					Char.clear();
					return 0;
				}				
				Char.push(str[i]); //将str[i]放入字符栈中
			}
			if (!Char.empty())//处理开头（）情况，因为到（这里，会被弹出来，而且还是第一位，所有为                                  空，那么下面Char.get_head()肯定报错
				if (Char.get_head() == '=')//到最后面了
					break;
		}
~~~

测试：

~~~c++
       * ****************************************************** *
        * ******************计算器功能系统界面****************** *
        *                                             退出：#     *
        *    注意：不支持'-'在第一位!不支持中文'()'! 如-3+2=          *
        *    可：(-3)+2.5*11-(25+11)/2=                          *
        *    例：3+(2*3)-6+(18/2)*(-2)=                          *
        *                                计算结果：               *
        * ****************************************************** *
        请输入：(-3)+2.5*11-(25+11)/2=
                                            计算结果：6.5
~~~

****

#### 思考&小结（两个是一样的*_~）

+ 对于这次作业来说呢，可能对我吧，有一定的难度。因为这次我并不能像上一周那样按时完成任务，怎么来说呢，可能我的知识点真的的有点差吧，速度不够快。但是说实话，我为了这次作业能顺利完成，两天基本在宿舍没有动过了。害、思考一下呢，对于c语言不够熟练，有些时候的错误很简单，但是就是好久才能发现。其次呢，数据结构可能掌握的不是很好，对计算器代码输写的时候，思路不是很清晰，导致基本的框架要搭建很长时间。然后对计算器的运行也经过多次检测，现在应该不会出现代码崩溃或者计算不正确的问题了。而对于链队列呢，主要的是一、对c++的模板不够熟练，刚刚开始想用模板的，可惜出现了许多问题，虽然后面可以实现了，但是觉得不够好。然后去学习void*，可能是由于时间问题，导致可能有点操之过急，不是很好的掌握void *的用法，从而出现了许多代码错误，而自己只能不知所措，浪费了许多时间，这也是不能按时完成任务的问题之一。总的来说，这次任务发现自己有许多问题存在，或许这也是我的收获之一吧。
+ 存在问题是存在，但是呢也不能总是说不好的一方面嘛。这次来说呢，收获是很大的，首先对栈和队列有了一个完全的了解，对链表呢也越来越熟练了。其次呢是计算器代码，对四则运算有了新的认识，从数据结构书上写的，到自己去上网找答案，现在学会了用双栈去实现四则运算，同时对代码逻辑有很大的帮助。对于范式链队列呢，之前都不知道一个链表中可以实现不同的数据类型，以前只是想过一下，现在有了让我实战的机会，怎么可能去放弃呢，虽然说有模板可以简单点，但是不够好（或许是我的模板写的差），去学习void *的用法，过程可能非常艰难，因为网上的知识点好像不是很好（可能我太笨了）。我这次能写出来呢，是结合了网上的说法，然后自己在vs中运行来检测，去分析，最后用到任务上了，当然花费的许多许多时间，不过我也实现的一个链表中存放不同数据类型的代码。所有来说嘛，过程是真的很艰难，但是结果的收获不也是很好吗。这一切都是值得的。
+ 下周计划吗？在我看来，计划可能永远赶不上变化，不过计划还是要有的，我上一周呢已经把图形渲染的初始化学到一半了，这一周应该完成对初始化的学习，然后继续去深入。而对于c++来说，还是要学习的，因为我发现我有时候是真的有点力不从心，所有呢把c++的学习也提上日程来才行。当然身体是革命的本钱，我也要去运动运动了。计划可能是这些吧，因为我计划可能不会想太多，我只是知道我该走的方向，然后去风雨兼程。我的总结就这么多了。
+ 当然还有一点，我很抱歉我不能按时完成任务||。